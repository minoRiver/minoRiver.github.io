---
layout: single
title:  "[유니티 그래픽스 최적화 스타트업 정리] 드로우콜"
author_profile: false
tag : [유니티 최적화]
categories : 유니티 최적화
typora-root-url: ../

---

> ## 개요

이 글은 "[유니티 그래픽스 최적화 스타트업](https://product.kyobobook.co.kr/detail/S000001888125)"이라는 책을 보고 정리한 글입니다.

유니티 관련 최적화를 찾아보면 항상 나오는 것 중 하나로 드로우콜을 줄이라는 글을 많이 봤습니다. 드로우콜이 도대체 무엇이며 이걸 왜 줄여야 하는지 항상 궁금했습니다. 오늘은 드로우콜에 관련해서 조사해 정리해봤습니다.



> ## 드로우콜(Draw Call)이란?

드로우콜이란 DP Call(Draw Primitive Call)과 렌더 상태(Render States) 등을 포함한 개념입니다.

DP Call은 CPU가 GPU에게 오브젝트를 렌더링하라고 명령을 보내는 것을 말합니다.  CPU는 현재 프레임에서 렌더링 할 오브젝트를 결정하고, 화면에 렌더링하는 것은 GPU에게 위임합니다. CPU가 GPU에게 오브젝트를 렌더링하라고 명령을 보낼 때 명령만으로는 오브젝트를 렌더링할 수 없기 때문에 그 전에 렌더 상태를 먼저 전달합니다.

렌더 상태란 GPU가 렌더링 해야 하는 오브젝트의 상태 정보를 의미합니다. 여기에는 텍스처, 쉐이더, 버텍스 같은 데이터들이 있습니다. GPU는 렌더 상태를 받으면 GPU 메모리에 저장해놨다가 DP Call을 받으면 오브젝트를 렌더링하기 위해 메모리에서 가져와 사용합니다. 이 때 렌더 상태들이 저장된 테이블을 렌더 상태 테이블이라고 합니다. 렌더 상태 테이블은 각 정보들이 GPU 메모리에 저장된 위치 정보를 가지고 있습니다.



> ## 유니티의 Batch 와 SetPass

드로우콜은 포괄적인 개념이기 때문에 유니티에서는 드로우콜을 Batch와 SetPass라는 용어로 나누어 표시하고 있습니다. 

Batch는 DP Call 과 상태 변경을 합친 넓은 의미의 드로우콜입니다. 그리고 SetPass는 드로우콜이 발생할 때 쉐이더로 인한 렌더링 패스 횟수를 의미합니다. 만약 똑같은 Batch 횟수여도 SetPass가 적은 쪽이 성능을 덜 사용하고 있다고 말할 수 있습니다.



> ## CPU가 GPU에게 명령을 전달하는 흐름

먼저 CPU는 컬링 연산을 통해 렌더링 대상인지 판별합니다. 그래서 최종적으로 렌더링 대상으로 판별된 오브젝트들의 렌더 상태를 전달합니다. 렌더 상태를 보낸 후, CPU는 마지막으로 GPU에게 DP Call명령을 전달합니다. 그러면 GPU는 렌더 상태 테이블에서 렌더링할 오브젝트의 렌더 상태를 찾아와 렌더링합니다. 그리고 다음 오브젝트를 그리기 위해 렌더 상태를 변경한 후 DP Call명령을 전달해 GPU가 렌더링하게 합니다. 이러한 작업을 오브젝트들이 모두 그려질 때까지 반복합니다.



> ## 커맨드 버퍼(Command Buffer)

사실 CPU가 GPU에게 렌더링 명령을 보낼 때 한 단계를 거칩니다. CPU는 특정 버퍼에 명령을 쌓아놓고 GPU는 작업이 끝나면 버퍼에 접근해 다음 명령을 가져가 수행합니다. 이러한 버퍼를 커맨드 버퍼라고 합니다.

이렇게 버퍼에 명령을 쌓아두고 가져가는 이유는 CPU가 GPU에게 직접 명령을 전달하게 되면 GPU가 작업 중인 경우 작업이 끝날 때까지 기다려야 하는데 이러면 CPU가 처리할 작업들이 멈추기 때문입니다. 그래서 버퍼에 명령을 쌓아놓고 가져가 작업을 하는 방식을 선택하여 CPU와 GPU가 병렬적으로 작업을 수행하게 하기 위해 커맨드 버퍼를 거쳐 명령을 전달하는 것입니다.



> ## 드로우콜이 병목 현상의 주요 원인 중 하나인 이유

유니티의 경우 멀티플랫폼 엔진입니다. 그렇기 때문에 다양한 OS 및 GPU에 대응한다는 강점이 있습니다. 하지만 CPU에서 GPU로 명령을 보낼 때, GPU가 해석할 수 있는 신호로 명령을 해석하고 변환하는 과정이 발생합니다. 이러한 과정은 명령을 보내는 과정에서 생기는 오버헤드입니다. 그리고 이러한 연산은 CPU에서 수행하기 때문에 드로우콜이 많이 발생하게 되면 그만큼 CPU 연산이 늘어나게 되며 병목의 원인이 될 수 있습니다. 그렇기 때문에 드로우콜을 줄여 드로우콜로 인한 오버헤드로 성능이 하락되는 것을 줄여야 합니다.



> ## 드로우콜 발생 조건

기본적으로 오브젝트를 하나 그릴 때 메시가 1개, 머티리얼이 1개라면 드로우콜이 한 번 일어납니다. 즉 1 Batch 입니다. 드로우콜은 여러 조건에 의해 하나의 오브젝트를 렌더링하는데 다수의 드로우콜이 발생할 수 있습니다. 또한 그리기 전에 상태 변경이 많이 이루어지는 경우도 있기 때문에 드로우콜이 발생하는 조건 외에도 상태 변경이 얼마나 일어나는지도 알아둬야 병목 지점이 발생하더라도 대처할 수 있습니다.



> ## 드로우콜이 여러 번 발생하는 조건

- 하나의 오브젝트를 이루는 메시가 여러 개인 경우

아래 사진처럼 하나의 메시처럼 보이지만 내부적으로 여러메시들로 이루어진 경우 같은 머티리얼을 공유하더라도 메시 개수만큼 드로우콜이 발생합니다.

![image-20230710171835184](/images/2023-07-10-fourth/image-20230710171835184.png)

![image-20230710171854217](/images/2023-07-10-fourth/image-20230710171854217.png)

<br>

- 머티리얼이 여러 개인 경우

아래 사진처럼 하나의 메시라도 여러 개의 머티리얼인 경우 그 개수만큼 드로우콜이 발생합니다.

![image-20230710172227229](images/2023-07-10-fourth/image-20230710172227229.png)

![image-20230710172242167](images/2023-07-10-fourth/image-20230710172242167.png)

<br>

- 쉐이더에 의한 경우

쉐이더 내에서 멀티 패스로 두 번 이상 렌더링을 거치기도 하는데 그렇게 되면 패스 개수만큼 드로우콜이 발생합니다. 대표적인 예가 외곽선입니다. 아래 사진처럼 메시를 그리고 추가로 외곽선을 그려주게 되면 두 번의 드로우콜이 발생하게 됩니다.

![image-20230710181504098](/images/2023-07-10-fourth/image-20230710181504098.png)
