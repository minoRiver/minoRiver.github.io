---
layout: single
title:  "[유니티 그래픽스 최적화 스타트업 정리] 배칭"
author_profile: false
tag : [유니티 최적화]
categories : 유니티 최적화
typora-root-url: ../
---

> ## 개요

이 글은 "[유니티 그래픽스 최적화 스타트업](https://product.kyobobook.co.kr/detail/S000001888125)"이라는 책을 보고 정리한 글입니다.

오늘은 유니티의 최적화 방법 중 하나인 배칭에 대해서 조사해봤습니다.



> ## 배칭(Batching)이란?

 여러 배치를 묶어서 하나의 배치로 만드는 것을 배칭이라고 합니다. 배칭은 드로우콜을 줄이기 위한 가장 효율적인 기능 중 하나입니다. 여러 드로우콜이 발생되는 경우 하나의 드로우콜로 묶는 배칭 과정을 거쳐 렌더링하여 드로우콜을 줄이는 방식입니다. 서로 다른 메시를 사용하는 오브젝트라도 같은 머티리얼을 사용하면 하나의 배치로 구성하는 것이 가능합니다. 그렇기 때문에 배칭을 하기 위해서는 머티리얼이 중요합니다.

배칭을 위해 서로 다른 메시를 사용하더라도 머티리얼을 공유해서 사용해야 하는데 이 때 여러 텍스처를 합쳐 텍스처 하나로 만들어 사용할 수 있는 텍스처 아틀라스 기법을 사용할 수 있습니다. 하지만 텍스처 아틀라스를 만들 때는 해상도 문제를 고려해야 합니다. 그 이유는 구형 디바이스의 경우 2048 해상도의 텍스처가 성능 저하의 이슈가 될 수 있기 때문입니다. 그렇기 때문에 해상도 문제가 발생할 수 있는 상황을 고려하면서 작업을 해야 합니다.

배칭에는 스태틱 배칭과 다이나믹 배칭이 있습니다.



> ## 스태틱 배칭(Static Batching)

스태틱 배칭은 정적 오브젝트, 즉 움직이지 않는 오브젝트들끼리 배칭처리를 하는 기능입니다. 스태틱 배칭을 사용하기 위해서는 오브젝트의 Batching Static 플래그가 켜져있어야 합니다.

스태틱 배칭은 다이나믹 배칭보다 효율적입니다. 그 이유는 다이나믹 배칭은 매번 배칭 구성을 위한 버텍스 연산이 필요하지만, 스태틱 배칭은 버텍스 연산은 런타임에 수행하지 않기 때입니다. 또한 스태틱 배칭은 메시의 폴리곤 수에 구애받지 않고 같은 머티리얼을 사용하는 메시들에게 적용되기 때문에 런타임에 움직이지 않는 오브젝트들은 플래그를 켜주는 것이 좋습니다.

하지만 스태틱 배칭은 추가적인 메모리를 필요로 한다는 단점이 있습니다. 그 이유는 각 오브젝트의 메시를 저장하기 위한 메모리 공간 외에도 여러 오브젝트의 메시를 합쳐 만든 메시를 저장하기 위한 메모리 공간을 필요로 하기 때문입니다.



> ## 다이나믹 배칭(Dynamic Batching)

다이나믹 배칭이란 동적으로 움직이는 오브젝트들끼리 배칭처리를 하는 기능입니다. 특정 조건들을 만족하는 다이나믹 오브젝트들은 배칭 작업이 이루어 지는데, 이 작업은 유니티에서 알아서 처리해 주기 때문에 별도의 추가적인 작업이 필요없습니다.



##### 다이나믹 배칭 처리 과정

1. 런타임에 과정이 수행되며 조건을 만족한 다이나믹 오브젝트들의 버텍스들을
   모아서 합쳐주는 과정을 거칩니다.
2. 모인 버텍스들을 모아서 다이나믹 배칭에 쓰이는 버텍스 버퍼와 인덱스 버퍼에
   담습니다.
3. GPU가 이 버퍼들을 가져가서 렌더링 합니다.

다이나믹 배칭은 이러한 처리 과정을 거치기 때문에 오버헤드가 발생하게 됩니다. 하지만 오버헤드를 갖더라도 드로우콜을 줄임으로써 전체적인 성능 향상을 노립니다. 이러한 오버헤드가 런타임에 발생하기 때문에 다이나믹 배칭은 많은 제약 사항들을 가집니다.

<br>

##### 다이나믹 배칭에서 제외되는 조건

1. Skinned Mesh는 다이나믹 배칭에서 제외됩니다. 그 이유는 애니메이션에 따라 스키닝 작업을 수행하는데 이러한 스키닝 작업은 GPU나 SIMD에서 고속으로 연산을 수행하는데, 다이나믹 배칭으로 묶으면 CPU 연산 효율이 떨어지기 때문입니다.
2. 버텍스가 너무 많은 메시는 다이나믹 배칭에서 제외됩니다. 그 이유는 다이나믹 배칭은 메시의 버텍스를 일일이 수집하여 연산하기 때문에 너무 많은 버텍스를 수집하는 경우 오히려 배칭 오버헤드 비용이 비싸지기 때문입니다.

이 외에도 제약 사항이 있는데 자세한 것은 [링크](https://docs.unity3d.com/Manual/DrawCallBatching.html)에서 확인 가능합니다.
