---
layout: single
title:  "[유니티 그래픽스 최적화 스타트업 정리] 렌더링 파이프라인"
author_profile: false
tag : [유니티 최적화]
categories : 유니티 최적화
typora-root-url: ../
---

> ## 개요

이 글은 "[유니티 그래픽스 최적화 스타트업](https://product.kyobobook.co.kr/detail/S000001888125)"이라는 책을 보고 정리한 글입니다.

3D 게임 월드 상의 물체들을 어떻게 2D 화면에 그릴 수 있는 것일까요? 오늘은 이러한 3D 월드의 오브젝트를 2D 화면으로 그리는 과정인 렌더링 파이프라인에 대해 조사해서 정리했습니다.

![로스트아크_시즌2_신규_대륙_파푸니카](/C:/Users/kangm/Desktop/로스트아크_시즌2_신규_대륙_파푸니카.jpg)



> ## 렌더링 파이프라인(Rendering Pipeline)이란?

렌더링 파이프라인이란 3차원 이미지를 2차원 래스터 이미지로 표현하기 위한 단계적인 방법을 말합니다. 여기서 말하는 래스터 이미지란 픽셀로 구성된 이미지를 말합니다. 실제 3차원 공간에 있는 오브젝트들을 2차원 모니터에 표현하려면 여러 과정을 거쳐야 하는데 이 과정이 렌더링 파이프라인이라 말할 수 있습니다.

렌더링 파이프라인 과정을 크게 보자면 애플리케이션, 지오메트리, 래스터라이저 세 파트로 나눌 수 있습니다. 실제로는 더 세부적인 파트들로 나뉘지만 공통적이고 핵심적인 과정들은 위의 3가지로 정도로 생각할 수 있습니다.

![img](https://lh4.googleusercontent.com/SHF7PYceH-Vvhz9F4TBpUBWWnFvguQ-27rFDXY2EeW-_DnpnXxkTl7FG65CZ2ZWohuou4U7TkjTI9Hoti0yn4ne_4YhnNiRQtWKBEMCOpsDPPqqqk085WCkcCY38JaYzbh3eYm5ru-rtVTJYuo8vQU8)

파이프라인이라는 단어에서 알 수 있듯이 한 부분이 막히는 경우 다른 부분까지 영향을 미칠 수 있습니다.

건물의 물탱크에서 가정의 수도꼭지까지 흘러가는 수도관을 예시로 들면, 물탱크에서 가정의 수도꼭지로 물이 흘러가다가 어느 한 구간에서 문제가 생긴다면 가정의 수도꼭지에서 물이 잘 나오지 않을 것입니다.

이와 마찬가지로 렌더링 파이프라인 중 어느 곳에서 문제가 발생하면 이로 인해 전체적인 성능에 영향을 끼칠 수 있습니다. 그렇기 때문에 렌더링 파이프라인 전체를 이해하고 있어야 하며, 만약 문제가 발생한다면 어느 구간에서 원인이 발생했는지 정확하게 파악할 필요가 있습니다.



> ## 애플리케이션(Application) 단계

애플리케이션 상에서 처리되는 단계를 의미합니다.

이 단계에서는 오브젝트가 렌더링되기 전에 업데이트 및 기타 데이터 처리, 렌더링될 오브젝트 선별 등의 작업을 처리합니다. 엄밀히 말하면 이 단계를 렌더링 파이프라인이라고 표현하지는 않습니다. 그 이유는 렌더링 파이프라인은 보통 GPU 파이프라인을 의미하는데 이 단계는 CPU 연산으로 진행되기 때문입니다. 하지만 본격적인 렌더링 파이프라인에 진입하기 전에 CPU에서 필요한 연산들을 처리해야 하기 때문에 큰 의미로는 렌더링 파이프라인의 일부분이 됩니다. 예를 들어 캐릭터의 경우 위치 정보와 애니메이션 정보 등을 렌더링 전에 처리해주고 GPU에 반영해줘야 합니다. 그렇기 때문에 렌더링을 위해서 반드시 거쳐야 하는 과정입니다.

애플리케이션 단계에서 현재 프레임에 렌더링 가능한 오브젝트들은 컬링 연산에 의해 선별됩니다. 컬링 연산으로 오브젝트들을 선별하게 되면 그만큼 GPU에서 처리할 연산량도 줄어들기 때문에 효율적으로 현재 프레임을 렌더링할 수 있습니다. 또한 배칭 처리를 위한 연산도 GPU 파이프라인에 진입하기 전에 이루어집니다.



> ## 메시(Mesh)

오브젝트들은 보통 메시의 형태로 우리 눈에 보입니다. 메시란 객체를 시각적으로 표현하기 위해 정점(Vertex)들을 연결하여 다각형 면(Polygon Face)을 형성하고 이를 그물처럼 표현한 모델입니다.

![img](https://lh3.googleusercontent.com/BsoEc--_hGz654YY15ZZZ-CiIKPzEXx5SyEjxtUSTNxSqQXUGTEd5sdRO1-GhXptaUwpVWOQ3piU9Lb-rTkJkdm_Xz-7q9NZ5q0S0JoRUV7sH2AkftcWib9pJROzdJZduHxtrIK4ypfXVD9vb89N9_A)

실제 메시는 여러 폴리곤(Polygon)으로 구성되어 있습니다. 여기서 말하는 폴리곤이란 엣지(Edge)가 모여 만들어진 삼각형을 의미합니다. 그리고 엣지란 정점(Vertex)가 모여서 만들어진 선을 말합니다. 정점이란 메시를 구성하고 있는 점들을 말합니다.

 ![제목 없음](/C:/Users/kangm/Desktop/제목 없음.png)



> ## 지오메트리(Geometry) 단계

지오메트리를 구성하는 요소인 버텍스(Vertex)와 폴리곤(Polygon)의 처리를 담당하는 단계입니다. 이 단계에서는 많은 과정들을 거칩니다. 지오메트리 단계에서는 전반적으로 오브젝트의 각 버텍스들을 화면상의 적절한 위치에 배치시키는 과정들입니다.

버텍스들을 적절한 위치에 배치시키기 위해 먼저 월드-뷰-프로젝션 트랜스폼(World-View-Projection Transform) 작업을 수행합니다.



> ## 월드-뷰-프로젝션 트랜스폼(World-View-Projection Transform)

월드-뷰-프로젝션 트랜스폼이란 메시의 정점 데이터들의 스페이스를 변환해주는 과정입니다. 이 과정에서는 버텍스, 월드, 뷰, 프로젝션 트랜스폼 작업을 수행합니다.

<br>

#### 버텍스 트랜스폼(Vertex Transform)

먼저 메시의 버텍스 데이터에 맞게 버텍스들의 위치를 옮겨줍니다. 하나의 메시는 여러 오브젝트 즉, 여러 인스턴스에서 사용되며 인스턴스마다 위치가
다릅니다. 또한 매번 위치가 바뀌기 때문에 3D 공간의 특정 위치가 반영되지 않는 원점 기준의 메시 모델에 대한 데이터(위치, 회전 등)가 있어야 합니다. 즉 로컬스페이스 상의 버텍스 데이터가 필요합니다. 이러한 버텍스 데이터는 GPU 메모리에 저장되어 있으며, 렌더링을 수행할 때 메모리에서 가져옵니다. 그리고 적절한 위치에 그려주기 위해 위치변환 트랜스폼을 수행한합니다.

<br>

##### 월드 트랜스폼(World Transform)

그 다음 오브젝트의 월드 스페이스로 트랜스폼하는 작업이 실행됩니다. 이 때는 로컬 스페이스의 메시의 정점 데이터들을 월드 스페이스로 변환시킵니다. 위치를 옮겨주는 것 뿐만 아니라 회전, 스케일 변환 작업과 정점의 노말(Normal) 같은 데이터 또한 월드 스페이스로 변환하는 작업을 합니다.

<br>

##### 뷰 트랜스폼(View Transform)

다음 작업은 뷰 트랜스폼 작업입니다. 즉 월드 스페이스의 정점 데이터를 뷰 스페이스로 변환하는 작업입니다. 뷰 스페이스는 카메라 스페이스라고도 불리며, 카메라를 원점으로 한 공간을 말합니다. 변환을 하는 이유는 카메라도 월드 상의 고유한 위치와 방향을 가지고 있다. 그렇기 때문에 카메라를 기준으로 한 뷰 스페이스로 변환하는 과정이 필요합니다. 그 이유는 오브젝트들은 카메라를 통해 화면에 그려지기 때문입니다.

<br>

##### 프로젝션 트랜스폼(Projection Transform)

마지막으로 프로젝션(투영) 트랜스폼 과정입니다. 투영이란 3D 공간의 오브젝트들을 2D 상의 위치로 매칭시켜주는 과정입니다. 뷰 트랜스폼 과정까지 수행한 오브젝트들은 아직 3차원 공간에 있는 상태입니다. 하지만 모니터 화면은 2차원이기 때문에 3D 공간 상의 오브젝트들을 2D 상의 위치로 변환하는 하는 과정이 필요한 것입니다.

투영에는 원근 투영과 직교 투영이 있는데 원근법이 적용되냐 안되냐의 여부로 나뉩니다. 즉 현실처럼 멀리 있으면 작게 보이고, 가까이 있으면 크게 보이는 것을 말합니다. 멀리 보이고 작게 보이고의 기준은 카메라와의 거리가 기준이 됩니다. 원근 투영이란 원근법이 적용된 투영 방법을 말하며, 직교 투영이란 원근법이 제거된 투영 방법을 말합니다.



> ## 버텍스 쉐이더(Vertex Shader)

버텍스 연산을 처리하는 쉐이더입니다. 트랜스폼 변환도 버텍스 쉐이더에서 이루어집니다. 트랜스폼 변환의 경우 메시의 버텍스에 행렬을 곱해줌으로써 수행됩니다.



> ## 지오메트리(Geometry) 생성

버텍스 쉐이더에서는 메시의 버텍스만 처리합니다. 그리고 버텍스 쉐이더 단계를 거치고 나면 처리된 버텍스들이 연결되어 선(Edge)이 만들어지고 도형의 형태가
됩니다. 그래픽스에서는 이러한 메시 도형의 형태를 지오메트리라고 부릅니다. 버텍스 쉐이더 단계에서 버텍스의 트랜스폼 변환 과정이 끝나고 나면 다음 단계에서 지오메트리 생성 작업이 자동으로 이루어집니다.
일부 최신 그래픽스 API에서는 쉐이더로 지오메트리 생성 단계에 관여할 수 있습니다.

- 지오메트리 쉐이더(Geometry Shader)
- 헐 쉐이더(Hull Shader)
- 도메인 쉐이더(Domain Shader)

이러한 쉐이더들을 이용해 테셀레이션(Tessellation)을 작업을 수행할 수 있습니다.



> ## 테셀레이션(Tessellation)

테셀레이션은 입력받은 버텍스 외에 추가로 버텍스를 생성하여 도형의 디테일을 더해 주는 기법입니다. 원래 테셀레이션은 PC 및 콘솔 등 성능이 높은 디바이스의 전유물이었지만, 최근에는 모바일 디바이스에서도 가능해졌습니다. Metal 이나 Vulkan 등의 최신 그래픽스 API에서 테셀레이션 기능을 지원합니다.



> ## 래스터라이즈(Rasterizer) 단계

렌더링할 메시가 화면에 매칭되는 픽셀을 결정하고 최종적으로 출력할 색을 결정하는 단계입니다. 래스터라이제이션이 이루어지고 나면 최종적으로 화면에 출력할 픽셀의 색을 결정합니다. 래스터라이제이션(Rasterization)이란 메시의 폴리곤에 속한 영역을 픽셀로 매칭시키는 과정을 말합니다.

또한 Z 테스트를 통해 현재 픽셀을 렌더링 할지말지 여부를 판단하는 과정을 수행합니다.



> ## 뎁스 버퍼(Depth Buffer), Z 버퍼(Z Buffer)

Z 테스트에 대해 설명하기 전에 Z 버퍼를 알아야 합니다. 뎁스 버퍼라고도 하는 이 버퍼는 픽셀의 깊이값을 저장합니다. 여기서 말하는 깊이값이란 카메라로부터의 거리를 뜻합니다.

Z 버퍼는 화면에 출력될 모든 픽셀들의 깊이값을 저장해야하기 때문에 컬러 버퍼(Color Buffer)와 사이즈가 동일합니다. 컬러 버퍼란 프래그먼트 쉐이더에서 결정된 픽셀의 최종 색상 정보를 저장하는 버퍼를 말합니다.

Z 테스트는 픽셀을 렌더링하기 전 Z 버퍼에서 현재 픽셀에 대응되는 깊이값을 가져와 현재 픽셀을 렌더링 할지말지 여부를 결정합니다. 일반적인 상황이라면 현재 그리려고 하는 픽셀이 Z 버퍼에 저장된 픽셀보다 앞에 있어야 렌더링됩니다. 여기서 말하는 앞이란 카메라 방향에서 봤을 때 앞에 있다는 것을 말합니다. 즉, 이미 픽셀에 렌더링된 위치가 현재 그리려는 위치보다 뒤에 있는 경우 픽셀을 렌더링합니다. 일반적으로 이미 그려진 픽셀에 다시 렌더링 하는 경우라면 Z 버퍼에 저장된 깊이값보다 현재 그리려고 하는 픽셀의 깊이값이 더 작습니다.

<br>

오브젝트들이 렌더링될 때 Z버퍼의 깊이값은 아래 사진처럼 채워집니다.(실제 저장되는 깊이값은 해당 사진의 깊이값과 다를 수 있음)

![image-20230713011840400](/C:/Users/kangm/AppData/Roaming/Typora/typora-user-images/image-20230713011840400.png)



> ## 오버드로우(Overdraw)

오버드로우란 화면에 렌더링되는 하나의 픽셀이 여러 번 덧그려지는 현상을 의미합니다.

Z 버퍼는 오버드로우 방지를 도와줍니다. 그 이유는 이미 그려진 픽셀의 깊이값이 Z 버퍼에 담기기 때문에 뒤에 있는 오브젝트가 렌더링되는 것을 방지하기 때문입니다. 하지만 뒤에 있는 오브젝트부터 그리게 되면 오버드로우가 발생하게 됩니다. 이는 성능 낭비이기 때문에 유니티의 경우 렌더링하기 전에 오브젝트들을 카메라와의 거리를 기준으로 정렬한 뒤 그 순서대로 렌더링합니다.



> ## 프래그먼트 쉐이더(Fragment Shader)

프래그먼트 쉐이더는 픽셀 쉐이더(Pixel Shader)라고 불리기도 합니다. 이 쉐이더에서는 최종 렌더링될 픽셀들의 색을 계산하는 작업을 수행합니다. 그래서 이 쉐이더에서는 텍스처로부터 색상을 읽어와 적용하거나, 그림자 연산, 라이팅 연산 등 다양한 일을 처리합니다.

프래그먼트 쉐이더에서 하는 라이팅 연산은 per-pixel 라이팅 연산으로 픽셀마다 라이팅 연산을 할 수 있습니다. 이렇게 하면 정밀한 라이팅 계산을 통해 게임의 오브젝트들을 보다 사실적으로 표현할 수 있습니다.

